/* 빅오 표기법 : 해당알고리즘이 얼마나 효과적인가를 수학적으로 표기하는 방법.

알고리즘이란,
알고리즘은 어떤 목적을 달성하거나 결과물을 만들어 내기 위해 거쳐야하는 일련의 과정

시간 복잡도(Time Complexity) - 알고리즘이 일련의 과정이 얼마나 시간이 걸리느냐 이야기야. 절대적인 시간이라는게 문제가 있어. 절대적 평가를 할수있는것들을 연산횟수를 결과물이 튀어나온다.
-> 문제를 해결하기 위한 연산 횟수를 의미한다.
공간 복잡도(Space Complexity)
공간복잡도로 따지면 퀵정렬이 안좋다. 배열을 복사하고 난리다. 버블정렬보다.  램에 올라가잖아. 512MB, 16GB 다 지금은. 의미가 없어진다.

-----------------------------------------------------------------------------------------------------------
시간 복잡도 <간단하게 각각이 어떤 느낌인지>
빅오 - 해당 알고리즘이 최소한 빅오로 표현된 시간보다는 빠르다. 
빅오메가 - 해당 알고리즘이 빨라봐야 빅오메가로 표현된 시간보다는 느리다.
빅세타 - 해당 알고리즘이 빅오로 시간보다는 빠르고 빅오메가로 표현된 시간보다는 느리다. (평균적으로 이렇다)
-----------------------------------------------------------------------------------------------------------
합리적으로 하는건 빅세타/ 빅오빅오 하는건 이유가 있다. 암묵적인 동의 이긴 한데/ 빅오를 빅세타처럼 이야기를 해.
암묵적 동의가 있다. 

퀵소트 다 정렬이 되어 있다면 n^2 이라는 소리야. 일반적으로는 nlogn 이다.

1.O(1) : 상수 시간 복잡도
2.O(log(N)) : 로그 시간 복잡도
3.O(N) : 선형 시간 복잡도
4.O(nlogn): 선형 로그 시간 복잡도
5.O(c^n) : 자수 시간 복잡도 : 최악의 시간 복잡도 2위 2^n
 O(N!) : 라플라스 공식 - 개판 오분전 이라는 소리야. 
6.O(N^2) : 2차 시간복잡도
7.O(N^3) : 3차 시간복잡도

데이터갯수(x), 연산횟수(y) 
점근적 표기법 - 상수 갯수는 날린다.


*/

void Func1(int n)
{
	int a = 10;
	if (a != 10)
	{
		int b = 10;

	}
}
//로그 시간 복잡도
	//일반적 커다란 문제를 일정한 크기를 갖는 문제로 쪼갤때 나타나는 유형.

	//이진탐색 정렬이 되어있어야 한다.
	//없으면 없는대로 끝나야한다.

	//이게 왜 로그 n이 나오냐?
	//데이터 개수1개 남을때까지 돌려야한다.
bool BinarySearch(int *arr, int len, int key)
{
	//sort(arr, arr + len);
	int start = 0;
	int end = len - 1;
	int mid = (start+end) / 2;
	while (end - start >= 0)
	{
		mid = (start + end) / 2;
		
		if (arr[mid] == key) return true;
		else if (arr[mid] > key)
			end = mid - 1;
		else start = mid + 1;
	}
	/*
	n: 탐색해야할 데이터 개수
	k: 시행횟수
	n/ 2^k = 1;
	-> n = 2^k
	->log(n) = k;
	*/

}

//퀵소트도 인간적으로 N^2 도는거 아닌가. 검사하는것도 드니까 말이다.아니구나. 정렬 안되면 맨 앞이 올 확률 이 
